<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chip-8 Emulator</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
      }
    }
  </script>
  <style>
    html,
    body {
      margin: 0;
    }
  </style>
</head>

<body>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import init, { Chip8 } from './pkg/chip8_web.js';

    await init();
    const test = await fetch('/roms/timendus/7-beep.ch8');
    const rom = await test.arrayBuffer();
    const romBuffer = new Uint8Array(rom);

    const chip8 = new Chip8();
    chip8.load_rom_from_bytes(romBuffer);

    let audioCtx = new AudioContext();
    let playing = false;

    let gain = audioCtx.createGain();
    gain.gain.value = 0.0;
    gain.connect(audioCtx.destination);

    let oscillator = audioCtx.createOscillator();
    oscillator.connect(gain);
    oscillator.type = "square";
    oscillator.start();

    /** @type {HTMLCanvasElement} */
    const canvas = document.createElement("canvas");
    canvas.width = 640;
    canvas.height = 320;
    const canvasContext = canvas.getContext("2d");
    const scaleFactor = 10;

    const newArray = new Uint8ClampedArray(64 * 32 * 4);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    camera.position.z = 2;

    const renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight
      camera.updateProjectionMatrix()
      renderer.setSize(window.innerWidth, window.innerHeight)
    });

    const planeGeometry = new THREE.PlaneGeometry(2, 1);
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.MeshBasicMaterial({ map: texture });
    const plane = new THREE.Mesh(planeGeometry, material);
    scene.add(plane);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.listenToKeyEvents(document.body)

    function draw() {
      renderer.render(scene, camera);
      texture.needsUpdate = true;

      for (let i = 0; i < 4; i++) {
        chip8.run();
      }
      chip8.decrement_timers();
      chip8.get_display().forEach((value, idx) => {
        newArray[idx * 4] = value * 255;
        newArray[idx * 4 + 1] = value * 255;
        newArray[idx * 4 + 2] = value * 255;
        newArray[idx * 4 + 3] = 255;
      });

      // Adjusting the scale
      const scaledImageData = scaleImageData(newArray, 64, scaleFactor);
      canvasContext.putImageData(scaledImageData, 0, 0);

      // Ideally this would just be calling start/stop on the oscillator,
      // but it seems like there's a race condition with rAF that causes
      // start to get called twice, so we just mute from the gain node instead
      if (chip8.get_sound_timer() > 0 && !playing) {
        gain.gain.value = 0.1;
        playing = true;
      } else if (chip8.get_sound_timer() == 0 && playing) {
        gain.gain.value = 0.0;
        playing = false;
      }

      requestAnimationFrame(draw);
    };

    function scaleImageData(imageData, width, scaleFactor) {
      // Calculate the dimensions of the scaled image data
      const scaledImageData = canvasContext.createImageData(width * scaleFactor, imageData.length / (width * 4) * scaleFactor);

      // Loop through each pixel in the scaled image data
      for (let y = 0; y < scaledImageData.height; y++) {
        for (let x = 0; x < scaledImageData.width; x++) {
          // Calculate the corresponding original (unscaled) coordinates
          const originalX = Math.floor(x / scaleFactor);
          const originalY = Math.floor(y / scaleFactor);

          // Calculate the index of the original pixel in the original image data array
          const originalIndex = (originalY * width + originalX) * 4;

          // Calculate the index of the current pixel in the scaled image data array
          const scaledIndex = (y * scaledImageData.width + x) * 4;

          // Copy pixel data from the original image data to the scaled image data
          for (let i = 0; i < 4; i++) {
            scaledImageData.data[scaledIndex + i] = imageData[originalIndex + i];
          }
        }
      }

      // Return the scaled image data
      return scaledImageData;
    }

    draw();
  </script>
</body>

</html>